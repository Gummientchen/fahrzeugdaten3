<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Car Data Search</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 10px; /* Reduced margin for more space */
        background-color: #f4f4f4;
      }
      .container {
        background-color: #fff;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .search-form {
        margin-bottom: 20px;
      }
      .search-form label {
        display: inline-block;
        width: 150px; /* Adjust as needed */
        margin-bottom: 5px;
        vertical-align: middle; /* Align with input */
      }
      .search-form input[type="text"] {
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        border-radius: 3px;
        width: 250px; /* Adjust as needed */
        vertical-align: middle; /* Align with input */
      }
      .search-form input[type="submit"] {
        padding: 10px 15px;
        background-color: #5cb85c;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }
      .search-form input[type="submit"]:hover {
        background-color: #4cae4c;
      }
      .results-count,
      .error-message,
      .no-results-message {
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 3px;
      }
      .results-count {
        background-color: #dff0d8;
        border: 1px solid #d6e9c6;
        color: #3c763d;
      }
      .error-message {
        background-color: #f2dede;
        border: 1px solid #ebccd1;
        color: #a94442;
      }
      .no-results-message {
        background-color: #fcf8e3;
        border: 1px solid #faebcc;
        color: #8a6d3b;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        table-layout: fixed; /* Added for more predictable column behavior */
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        /* General word break for all cells, can be overridden */
        word-wrap: break-word; /* For older browsers */
        overflow-wrap: break-word;
      }
      th {
        background-color: #f0f0f0;
      }
      /* Style for the first column (labels) in accordion tables */
      .accordion-panel table td:first-child {
        width: 40%; /* Adjust percentage as needed for label column width */
        /* overflow-wrap is inherited from general td style, add hyphens */
        -webkit-hyphens: auto;
        -ms-hyphens: auto;
        hyphens: auto;
      }
      /* Style for the second column (values) in accordion tables */
      .accordion-panel table td:nth-child(2) {
        width: 60%; /* Adjust percentage as needed for value column width */
        word-break: break-all; /* More aggressive breaking for values if needed */
      }
      .accordion-panel > div > table {
        /* Target tables inside the accordion's overflow div */
        margin-left: 0; /* Remove any left margin */
      }
      /* .group-title { (Old style, replaced by accordion header)
        font-size: 1.2em;
        font-weight: bold;
        margin-top: 20px;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 2px solid #eee;
      } */
      .multiple-results-list {
        list-style-type: none; /* Remove bullet points */
        padding-left: 0; /* Remove default padding for ul */
      }
      .multiple-results-list li {
        margin-bottom: 5px;
        padding: 5px;
        border-radius: 3px;
        /* New styles for card-like appearance */
        background-color: #f9f9f9;
        border: 1px solid #eee;
        padding: 10px 15px;
        margin-bottom: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      }
      .multiple-results-list li div {
        margin-bottom: 5px; /* Space between data lines in the card */
      }
      .clickable-tg-code {
        cursor: pointer;
        color: #007bff; /* Make it look like a link */
      }
      .form-field-container {
        position: relative;
        margin-bottom: 10px; /* Match original input margin + <br> effect */
      }
      .autocomplete-suggestions {
        border: 1px solid #ccc;
        border-top: none;
        max-height: 150px;
        overflow-y: auto;
        position: absolute;
        background-color: white;
        z-index: 1000;
        /* Make suggestions box align under and match width of the input field */
        width: 250px; /* Should match the width of #marke_input and #typ_input */
        left: 150px; /* Should be approx the width of the label to align under input */
        /* If label width is 150px, and input is directly next to it. */
        box-sizing: border-box;
        display: none; /* Initially hidden */
      }
      .autocomplete-suggestions div {
        padding: 8px;
        cursor: pointer;
      }
      .autocomplete-suggestions div:hover {
        background-color: #f0f0f0;
      }
      .form-field-container input[type="text"] {
        margin-bottom: 0; /* Override general margin, space is now handled by container's margin-bottom */
      }
      /* Accordion Styles */
      .accordion-header {
        background-color: #e9ecef; /* Light grey, distinct from table header */
        color: #495057;
        cursor: pointer;
        padding: 12px 18px;
        width: 100%;
        border: none;
        text-align: left;
        outline: none;
        font-size: 1.1em;
        font-weight: bold;
        transition: background-color 0.3s ease;
        margin-top: 8px;
        border-radius: 4px;
        border-bottom: 1px solid #ced4da;
      }
      .accordion-header.active,
      .accordion-header:hover {
        background-color: #dee2e6;
      }
      .accordion-header:after {
        /* Plus/Minus icon */
        content: "\002B"; /* Plus */
        font-size: 1.1em;
        color: #495057;
        float: right;
        margin-left: 5px;
      }
      .accordion-header.active:after {
        content: "\2212"; /* Minus */
      }
      .accordion-panel {
        padding: 0; /* Panel itself has no padding, table inside will */
        background-color: white;
        display: none; /* Hidden by default */
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Car Data Search</h1>

      <div class="search-form">
        <form method="POST" action="/">
          <label for="tg_code_input">TG-Code:</label>
          <!-- Changed id to tg_code_input for consistency -->
          <input
            type="text"
            name="tg_code"
            id="tg_code_input"
            value="{{ request.form.tg_code }}"
          /><br />

          <div class="form-field-container">
            <label for="marke_input">Marke (fuzzy):</label>
            <input
              type="text"
              name="marke"
              id="marke_input"
              value="{{ request.form.marke }}"
              autocomplete="off"
            />
            <div id="marke_suggestions" class="autocomplete-suggestions"></div>
          </div>

          <div class="form-field-container">
            <label for="typ_input">Typ (fuzzy):</label>
            <input
              type="text"
              name="typ"
              id="typ_input"
              value="{{ request.form.typ }}"
              autocomplete="off"
            />
            <div id="typ_suggestions" class="autocomplete-suggestions"></div>
          </div>

          <!-- Removed the <br> here as form-field-container handles spacing -->

          <input type="submit" value="Search" />
        </form>
      </div>

      {% if error_message %}
      <div class="error-message">{{ error_message }}</div>
      {% endif %} {% if search_performed and not error_message %} {% if results
      %}
      <div class="results-count">Found {{ results|length }} result(s).</div>

      {% if results|length == 1 %} {% set car_data_grouped = results[0] %}
      <h2>Car Details</h2>
      {% for group_name in data_groups_order %} {% if group_name in
      car_data_grouped and car_data_grouped[group_name] %}
      <button class="accordion-header">{{ group_name }}</button>
      <div class="accordion-panel">
        <div style="overflow-x: auto; padding: 15px 0">
          <!-- For responsive tables & panel content padding -->
          <table>
            {% for key, value in car_data_grouped[group_name].items() %}
            <tr>
              <td>{{ key|safe }}</td>
              {# Label cell - will use td:first-child style #}
              <td>{{ value }}</td>
              {# Value cell - will use td:nth-child(2) style #}
            </tr>
            {% endfor %}
          </table>
        </div>
      </div>
      {% endif %} {% endfor %} {% else %} {# Multiple results #}
      <h2>Multiple Results Found</h2>
      <p>
        Please refine your search, possibly by using a specific TG-Code from the
        list below.
      </p>
      <ul class="multiple-results-list">
        {% for car_summary in results %} {# These keys must match what search.py
        returns for multiple results (raw dict from DB) #}
        <li>
          <div
            class="clickable-tg-code"
            data-tgcode="{{ car_summary.get('cars_tg_code', '') }}"
          >
            <strong>TG-Code:</strong>
            {{ car_summary.get('cars_tg_code', 'N/A') }}
          </div>
          <div>
            <strong>Marke:</strong> {{
            car_summary.get('cars_col_04_marke_value', 'N/A') }}
          </div>
          <div>
            <strong>Typ:</strong> {{ car_summary.get('cars_col_04_typ_value',
            'N/A') }}
          </div>
        </li>
        {% endfor %}
      </ul>
      {% endif %} {% else %}
      <div class="no-results-message">No results found for your criteria.</div>
      {% endif %} {% endif %}

      <script>
        function setupAutocomplete(
          inputId,
          suggestionsId,
          endpointUrl,
          isTypField = false
        ) {
          const inputField = document.getElementById(inputId);
          const suggestionsContainer = document.getElementById(suggestionsId);
          let debounceTimer;

          inputField.addEventListener("input", function () {
            clearTimeout(debounceTimer);
            const term = this.value;

            debounceTimer = setTimeout(async () => {
              suggestionsContainer.innerHTML = ""; // Clear previous suggestions
              suggestionsContainer.style.display = "none";

              if (term.length < 1) {
                // Minimum characters to trigger autocomplete
                return;
              }

              let currentEndpointUrl = `${endpointUrl}?term=${encodeURIComponent(
                term
              )}`;
              if (isTypField) {
                const markeValue = document.getElementById("marke_input").value;
                if (markeValue && markeValue.trim()) {
                  // Ensure markeValue is not empty and not just whitespace
                  currentEndpointUrl += `&marke=${encodeURIComponent(
                    markeValue.trim()
                  )}`;
                }
              }

              try {
                const response = await fetch(currentEndpointUrl);
                if (!response.ok) {
                  console.error(
                    "Autocomplete fetch error:",
                    response.status,
                    response.statusText
                  );
                  return;
                }
                const suggestions = await response.json();

                if (suggestions.length > 0) {
                  suggestionsContainer.style.display = "block";
                  suggestions.forEach((suggestion) => {
                    const div = document.createElement("div");
                    div.textContent = suggestion;
                    div.addEventListener("click", function () {
                      inputField.value = suggestion;
                      suggestionsContainer.innerHTML = "";
                      suggestionsContainer.style.display = "none";
                    });
                    suggestionsContainer.appendChild(div);
                  });
                }
              } catch (error) {
                console.error("Autocomplete request failed:", error);
              }
            }, 250); // 250ms debounce delay
          });

          document.addEventListener("click", function (event) {
            if (
              !inputField.contains(event.target) &&
              !suggestionsContainer.contains(event.target)
            ) {
              suggestionsContainer.innerHTML = "";
              suggestionsContainer.style.display = "none";
            }
          });
        }

        document.addEventListener("DOMContentLoaded", function () {
          setupAutocomplete(
            "marke_input",
            "marke_suggestions",
            "/autocomplete/marken"
          );
          setupAutocomplete(
            "typ_input",
            "typ_suggestions",
            "/autocomplete/typen",
            true
          ); // Pass true for isTypField

          // Cookie helper functions
          function setCookie(name, value, days) {
            let expires = "";
            if (days) {
              const date = new Date();
              date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
              expires = "; expires=" + date.toUTCString();
            }
            document.cookie =
              name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
          }
          function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(";");
            for (let i = 0; i < ca.length; i++) {
              let c = ca[i];
              while (c.charAt(0) === " ") c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) === 0)
                return c.substring(nameEQ.length, c.length);
            }
            return null;
          }

          // Accordion Logic
          const accHeaders = document.querySelectorAll(".accordion-header");
          accHeaders.forEach((header) => {
            header.addEventListener("click", function () {
              this.classList.toggle("active");
              const panel = this.nextElementSibling;
              if (panel.style.display === "block") {
                panel.style.display = "none";
              } else {
                panel.style.display = "block";
              }
              // Save open accordion state to cookie
              const openAccordions = [];
              accHeaders.forEach((h) => {
                if (h.classList.contains("active")) {
                  openAccordions.push(h.textContent.trim());
                }
              });
              setCookie("openAccordions", JSON.stringify(openAccordions), 180); // Save for 180 days
            });
          });

          // Restore accordion state from cookie or open the first one
          if (accHeaders.length > 0) {
            const carDetailsTitle = document.querySelector("h2");
            // Check if the h2 "Car Details" exists, indicating single result view
            if (
              carDetailsTitle &&
              carDetailsTitle.textContent.trim() === "Car Details"
            ) {
              const savedOpenAccordions = getCookie("openAccordions");
              if (savedOpenAccordions) {
                try {
                  const openLabels = JSON.parse(savedOpenAccordions);
                  accHeaders.forEach((header) => {
                    if (openLabels.includes(header.textContent.trim())) {
                      header.classList.add("active");
                      header.nextElementSibling.style.display = "block";
                    }
                  });
                } catch (e) {
                  console.error("Error parsing accordion cookie", e);
                }
              } else {
                // Default: Open the first accordion panel if no cookie
                const firstHeader = accHeaders[0];
                firstHeader.classList.add("active");
                firstHeader.nextElementSibling.style.display = "block";
              }
            }
          }

          // Handle clicks on TG-Codes in multiple results
          const multipleResultsList = document.querySelector(
            ".multiple-results-list"
          );
          if (multipleResultsList) {
            multipleResultsList.addEventListener("click", function (event) {
              let targetElement = event.target;
              // Traverse up if the click was on the <strong> or text node inside the div
              while (
                targetElement != null &&
                !targetElement.classList.contains("clickable-tg-code")
              ) {
                targetElement = targetElement.parentElement;
              }

              if (
                targetElement &&
                targetElement.classList.contains("clickable-tg-code")
              ) {
                const tgCode = targetElement.dataset.tgcode;
                if (tgCode) {
                  document.getElementById("tg_code_input").value = tgCode;
                  document.getElementById("marke_input").value = ""; // Clear Marke field
                  document.getElementById("typ_input").value = ""; // Clear Typ field
                  document.querySelector(".search-form form").submit();
                }
              }
            });
          }
        });
      </script>
    </div>
  </body>
</html>
