<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Car Data Search</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 10px; /* Reduced margin for more space */
        background-color: #f4f4f4;
      }
      .container {
        background-color: #fff;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .search-form {
        margin-bottom: 20px;
      }
      .search-form label {
        display: inline-block;
        width: 150px; /* Adjust as needed */
        margin-bottom: 5px;
        vertical-align: middle; /* Align with input */
      }
      .search-form input[type="text"] {
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        border-radius: 3px;
        width: 250px; /* Adjust as needed */
        vertical-align: middle; /* Align with input */
      }
      .search-form input[type="submit"] {
        padding: 10px 15px;
        background-color: #5cb85c;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }
      .search-form input[type="submit"]:hover {
        background-color: #4cae4c;
      }
      .results-count,
      .error-message,
      .no-results-message {
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 3px;
      }
      .results-count {
        background-color: #dff0d8;
        border: 1px solid #d6e9c6;
        color: #3c763d;
      }
      .error-message {
        background-color: #f2dede;
        border: 1px solid #ebccd1;
        color: #a94442;
      }
      .no-results-message {
        background-color: #fcf8e3;
        border: 1px solid #faebcc;
        color: #8a6d3b;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        table-layout: fixed; /* Added for more predictable column behavior */
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        /* General word break for all cells, can be overridden */
        word-wrap: break-word; /* For older browsers */
        overflow-wrap: break-word;
      }
      th {
        background-color: #f0f0f0;
      }
      /* Style for the first column (labels) in accordion tables */
      .accordion-panel table td:first-child {
        width: 40%; /* Adjust percentage as needed for label column width */
        /* overflow-wrap is inherited from general td style, add hyphens */
        -webkit-hyphens: auto;
        -ms-hyphens: auto;
        hyphens: auto;
      }
      /* Style for the second column (values) in accordion tables */
      .accordion-panel table td:nth-child(2) {
        width: 60%; /* Adjust percentage as needed for value column width */
        word-break: break-all; /* More aggressive breaking for values if needed */
      }
      .accordion-panel > div > table {
        /* Target tables inside the accordion's overflow div */
        margin-left: 0; /* Remove any left margin */
      }
      /* .group-title { (Old style, replaced by accordion header)
        font-size: 1.2em;
        font-weight: bold;
        margin-top: 20px;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 2px solid #eee;
      } */
      .multiple-results-list {
        list-style-type: none; /* Remove bullet points */
        padding-left: 0; /* Remove default padding for ul */
      }
      .multiple-results-list li {
        margin-bottom: 5px;
        padding: 5px;
        border-radius: 3px;
        /* New styles for card-like appearance */
        background-color: #f9f9f9;
        border: 1px solid #eee;
        padding: 10px 15px;
        margin-bottom: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      }
      .multiple-results-list li div {
        margin-bottom: 5px; /* Space between data lines in the card */
      }
      .clickable-tg-code {
        cursor: pointer;
        color: #007bff; /* Make it look like a link */
      }
      .form-field-container {
        position: relative;
        margin-bottom: 10px; /* Match original input margin + <br> effect */
      }
      .autocomplete-suggestions {
        border: 1px solid #ccc;
        border-top: none;
        max-height: 150px;
        overflow-y: auto;
        position: absolute;
        background-color: white;
        z-index: 1000;
        /* Make suggestions box align under and match width of the input field */
        width: 250px; /* Should match the width of #marke_input and #typ_input */
        left: 150px; /* Should be approx the width of the label to align under input */
        /* If label width is 150px, and input is directly next to it. */
        box-sizing: border-box;
        display: none; /* Initially hidden */
      }
      .autocomplete-suggestions div {
        padding: 8px;
        cursor: pointer;
      }
      .autocomplete-suggestions div:hover {
        background-color: #f0f0f0;
      }
      .form-field-container input[type="text"] {
        margin-bottom: 0; /* Override general margin, space is now handled by container's margin-bottom */
      }
      /* Accordion Styles */
      .accordion-header {
        background-color: #e9ecef; /* Light grey, distinct from table header */
        color: #495057;
        cursor: pointer;
        padding: 12px 18px;
        width: 100%;
        border: none;
        text-align: left;
        outline: none;
        font-size: 1.1em;
        font-weight: bold;
        transition: background-color 0.3s ease;
        margin-top: 8px;
        border-radius: 4px;
        border-bottom: 1px solid #ced4da;
      }
      .accordion-header.active,
      .accordion-header:hover {
        background-color: #dee2e6;
      }
      .accordion-header:after {
        /* Plus/Minus icon */
        content: "\002B"; /* Plus */
        font-size: 1.1em;
        color: #495057;
        float: right;
        margin-left: 5px;
      }
      .accordion-header.active:after {
        content: "\2212"; /* Minus */
      }
      .accordion-panel {
        padding: 0; /* Panel itself has no padding, table inside will */
        background-color: white;
        display: none; /* Hidden by default */
        overflow: hidden;
      }
      /* Search History Styles */
      #search_history_btn {
        padding: 8px 12px;
        margin-left: 10px; /* Space next to Search button */
        background-color: #6c757d; /* A neutral color */
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        vertical-align: middle; /* Align with other form elements */
      }
      #search_history_btn:hover {
        background-color: #5a6268;
      }
      .search-history-dropdown {
        position: absolute;
        background-color: white;
        border: 1px solid #ccc;
        z-index: 1001; /* Above autocomplete */
        max-height: 250px;
        overflow-y: auto;
        width: 300px; /* Adjust as needed */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        margin-top: 5px; /* Space below the button row */
      }
      .search-history-dropdown ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }
      .search-history-dropdown li {
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }
      .search-history-dropdown li:last-child {
        border-bottom: none;
      }
      .search-history-dropdown li:hover {
        background-color: #f0f0f0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Car Data Search</h1>

      <div class="search-form">
        <form method="POST" action="/">
          <label for="tg_code_input">TG-Code:</label>
          <!-- Changed id to tg_code_input for consistency -->
          <input
            type="text"
            name="tg_code"
            id="tg_code_input"
            value="{{ request.form.tg_code }}"
          /><br />

          <div class="form-field-container">
            <label for="marke_input">Marke (fuzzy):</label>
            <input
              type="text"
              name="marke"
              id="marke_input"
              value="{{ request.form.marke }}"
              autocomplete="off"
            />
            <div id="marke_suggestions" class="autocomplete-suggestions"></div>
          </div>

          <div class="form-field-container">
            <label for="typ_input">Typ (fuzzy):</label>
            <input
              type="text"
              name="typ"
              id="typ_input"
              value="{{ request.form.typ }}"
              autocomplete="off"
            />
            <div id="typ_suggestions" class="autocomplete-suggestions"></div>
          </div>

          <!-- Removed the <br> here as form-field-container handles spacing -->

          <input type="submit" value="Search" />
          <button type="button" id="search_history_btn">Search History</button>
          <div
            id="search_history_container"
            class="search-history-dropdown"
            style="display: none"
          >
            <ul id="search_history_list"></ul>
          </div>
        </form>
      </div>

      {% if error_message %}
      <div class="error-message">{{ error_message }}</div>
      {% endif %} {% if search_performed and not error_message %} {% if results
      %}
      <div class="results-count">Found {{ results|length }} result(s).</div>

      {% if results|length == 1 %} {% set car_data_grouped = results[0] %}
      <h2>Car Details</h2>
      {% for group_name in data_groups_order %} {% if group_name in
      car_data_grouped and car_data_grouped[group_name] %}
      <button class="accordion-header">{{ group_name }}</button>
      <div class="accordion-panel">
        <div style="overflow-x: auto; padding: 15px 15px 15px 0">
          <!-- For responsive tables & panel content padding -->
          <table>
            {% for key, value in car_data_grouped[group_name].items() %}
            <tr>
              <td>{{ key|safe }}</td>
              {# Label cell - will use td:first-child style #}
              <td>{{ value }}</td>
              {# Value cell - will use td:nth-child(2) style #}
            </tr>
            {% endfor %}
          </table>
        </div>
      </div>
      {% endif %} {% endfor %} {% else %} {# Multiple results #}
      <h2>Multiple Results Found</h2>
      <p>
        Please refine your search, possibly by using a specific TG-Code from the
        list below.
      </p>
      <ul class="multiple-results-list">
        {% for car_summary in results %} {# These keys must match what search.py
        returns for multiple results (raw dict from DB) #}
        <li>
          <div
            class="clickable-tg-code"
            data-tgcode="{{ car_summary.get('cars_tg_code', '') }}"
          >
            <strong>TG-Code:</strong>
            {{ car_summary.get('cars_tg_code', 'N/A') }}
          </div>
          <div>
            <strong>Marke:</strong> {{
            car_summary.get('cars_col_04_marke_value', 'N/A') }}
          </div>
          <div>
            <strong>Typ:</strong> {{ car_summary.get('cars_col_04_typ_value',
            'N/A') }}
          </div>
        </li>
        {% endfor %}
      </ul>
      {% endif %} {% else %}
      <div class="no-results-message">No results found for your criteria.</div>
      {% endif %} {% endif %}

      <script>
        // SCRIPT BLOCK 1: GLOBAL DEFINITIONS FOR HISTORY - MUST BE BEFORE EMBEDDED SCRIPT
        const MAX_HISTORY_ITEMS = 10;
        const HISTORY_COOKIE_NAME = "carSearchHistory";

        function setCookie(name, value, days) {
          let expires = "";
          if (days) {
            const date = new Date();
            date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
            expires = "; expires=" + date.toUTCString();
          }
          document.cookie =
            name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
          const nameEQ = name + "=";
          const ca = document.cookie.split(";");
          for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === " ") c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0)
              return c.substring(nameEQ.length, c.length);
          }
          return null;
        }

        window.addSearchToHistory = function (tgCode, displayName) {
          if (!tgCode || !displayName) return;
          let history = [];
          const savedHistory = getCookie(HISTORY_COOKIE_NAME); // Uses global getCookie
          if (savedHistory) {
            try {
              history = JSON.parse(savedHistory);
            } catch (e) {
              console.error(
                "Error parsing search history cookie in addSearchToHistory",
                e
              );
              history = [];
            }
          }
          history = history.filter((item) => item.tgCode !== tgCode);
          history.unshift({ tgCode: tgCode, display: displayName });
          if (history.length > MAX_HISTORY_ITEMS) {
            history = history.slice(0, MAX_HISTORY_ITEMS);
          }
          setCookie(HISTORY_COOKIE_NAME, JSON.stringify(history), 180); // Uses global setCookie
        };
      </script>

      {% if results and results|length == 1 %} {# This script block will only be
      rendered if a single car result is displayed #} {# It's used to add the
      current car to the search history #}
      <script>
        document.addEventListener('DOMContentLoaded', function() {
          console.log("History Saver (Embedded Script): DOMContentLoaded fired."); // Log 1: Is this script block running?

          console.log("History Saver (Embedded Script): typeof addSearchToHistory:", typeof addSearchToHistory); // Log 2: Is the function defined?
          console.log("History Saver (Embedded Script): window.addSearchToHistory:", window.addSearchToHistory); // Log 3: What is it?

          // Ensure addSearchToHistory is defined (it will be later in the main script block)
          if (typeof window.addSearchToHistory === 'function') { // Explicitly check window object
            console.log("History Saver (Embedded Script): addSearchToHistory IS a function. Proceeding..."); // Log 4
            const carDataForHistory = {{ car_data_grouped|tojson|safe }}; // Use |safe with |tojson
            const groupOrderForHistory = {{ data_groups_order|tojson|safe }}; // Use |safe with |tojson

            let tgCodeForHistory = "";
            let markeForHistory = "";
            let typForHistory = "";

            // Use the actual labels passed from Flask. |tojson handles special chars like &shy; -> \u00AD
            const actualTgCodeLabelJS = {{ actual_tg_code_label|tojson|safe }};
            const actualMarkeLabelJS = {{ actual_marke_label|tojson|safe }};
            const actualTypLabelJS = {{ actual_typ_label|tojson|safe }};

            console.log("History Saver (Embedded Script): Expected TG Label:", actualTgCodeLabelJS); // Log 5
            console.log("History Saver (Embedded Script): Expected Marke Label:", actualMarkeLabelJS); // Log 6
            console.log("History Saver (Embedded Script): Expected Typ Label:", actualTypLabelJS); // Log 7
            // console.log("History Saver (Embedded Script): Full Car Data:", JSON.stringify(carDataForHistory, null, 2)); // Uncomment for very detailed debugging

            for (const groupName of groupOrderForHistory) {
                if (carDataForHistory[groupName]) {
                    const group = carDataForHistory[groupName];
                    // console.log("History Saver (Embedded Script): Checking group:", groupName, group); // Uncomment for group-level debugging
                    // Use the dynamic labels for lookup
                    if (group[actualTgCodeLabelJS] && !tgCodeForHistory) {
                        // TG-Code itself should not have units, but let's be safe and split by space
                        // in case it's a string that somehow got a unit or extra info.
                        tgCodeForHistory = String(group[actualTgCodeLabelJS]).split(" ")[0];
                        console.log("History Saver (Embedded Script): Found TG Code:", tgCodeForHistory); // Log 8
                    }
                    if (group[actualMarkeLabelJS] && !markeForHistory) {
                        markeForHistory = String(group[actualMarkeLabelJS]); // Marke usually doesn't have units
                        console.log("History Saver (Embedded Script): Found Marke:", markeForHistory); // Log 9
                    }
                    if (group[actualTypLabelJS] && !typForHistory) {
                        typForHistory = String(group[actualTypLabelJS]); // Typ usually doesn't have units
                        console.log("History Saver (Embedded Script): Found Typ:", typForHistory); // Log 10
                    }
                }
            }

            console.log("History Saver (Embedded Script): Extracted - TG:", tgCodeForHistory, "Marke:", markeForHistory, "Typ:", typForHistory); // Log 11

            if (tgCodeForHistory) {
                let displayNameForHistory = ((markeForHistory || "") + " " + (typForHistory || "")).trim();
                displayNameForHistory = displayNameForHistory ? `${displayNameForHistory} (${tgCodeForHistory})` : `TG: ${tgCodeForHistory}`;
                console.log("History Saver (Embedded Script): Adding to history with DisplayName:", displayNameForHistory, "and TGCode:", tgCodeForHistory); // Log 12
                window.addSearchToHistory(tgCodeForHistory, displayNameForHistory); // Call the global function
            } else {
                console.warn("History Saver (Embedded Script): No TG Code found for the current car. Not adding to history."); // Log 13
            }
          } else {
            console.error("History Saver (Embedded Script): addSearchToHistory is NOT a function or not defined on window."); // Log 14
          }
        });
      </script>
      {% endif %}

      <script>
        // SCRIPT BLOCK 2: DOM MANIPULATION AND EVENT LISTENERS
        function setupAutocomplete(
          inputId,
          suggestionsId,
          endpointUrl,
          isTypField = false
        ) {
          const inputField = document.getElementById(inputId);
          const suggestionsContainer = document.getElementById(suggestionsId);
          let debounceTimer;

          inputField.addEventListener("input", function () {
            clearTimeout(debounceTimer);
            const term = this.value;

            debounceTimer = setTimeout(async () => {
              suggestionsContainer.innerHTML = ""; // Clear previous suggestions
              suggestionsContainer.style.display = "none";

              if (term.length < 1) {
                // Minimum characters to trigger autocomplete
                return;
              }

              let currentEndpointUrl = `${endpointUrl}?term=${encodeURIComponent(
                term
              )}`;
              if (isTypField) {
                const markeValue = document.getElementById("marke_input").value;
                if (markeValue && markeValue.trim()) {
                  // Ensure markeValue is not empty and not just whitespace
                  currentEndpointUrl += `&marke=${encodeURIComponent(
                    markeValue.trim()
                  )}`;
                }
              }

              try {
                const response = await fetch(currentEndpointUrl);
                if (!response.ok) {
                  console.error(
                    "Autocomplete fetch error:",
                    response.status,
                    response.statusText
                  );
                  return;
                }
                const suggestions = await response.json();

                if (suggestions.length > 0) {
                  suggestionsContainer.style.display = "block";
                  suggestions.forEach((suggestion) => {
                    const div = document.createElement("div");
                    div.textContent = suggestion;
                    div.addEventListener("click", function () {
                      inputField.value = suggestion;
                      suggestionsContainer.innerHTML = "";
                      suggestionsContainer.style.display = "none";
                    });
                    suggestionsContainer.appendChild(div);
                  });
                }
              } catch (error) {
                console.error("Autocomplete request failed:", error);
              }
            }, 250); // 250ms debounce delay
          });

          document.addEventListener("click", function (event) {
            if (
              !inputField.contains(event.target) &&
              !suggestionsContainer.contains(event.target)
            ) {
              suggestionsContainer.innerHTML = "";
              suggestionsContainer.style.display = "none";
            }
          });
        }

        document.addEventListener("DOMContentLoaded", function () {
          setupAutocomplete(
            "marke_input",
            "marke_suggestions",
            "/autocomplete/marken"
          );
          setupAutocomplete(
            "typ_input",
            "typ_suggestions",
            "/autocomplete/typen",
            true
          ); // Pass true for isTypField

          // Search History display logic (uses global getCookie)
          // addSearchToHistory is now globally defined in the script block above the embedded script

          function displaySearchHistory() {
            const historyList = document.getElementById("search_history_list");
            historyList.innerHTML = ""; // Clear previous items
            const savedHistory = getCookie(HISTORY_COOKIE_NAME);
            let historyItems = []; // Initialize as empty array

            if (savedHistory) {
              try {
                historyItems = JSON.parse(savedHistory);
              } catch (e) {
                console.error(
                  "Error parsing search history cookie for display",
                  e
                );
                historyItems = []; // Reset to empty on error if parsing fails
              }
            }

            if (historyItems && historyItems.length > 0) {
              historyItems.forEach((item) => {
                const li = document.createElement("li");
                li.textContent = item.display;
                li.dataset.tgcode = item.tgCode;
                li.addEventListener("click", function () {
                  document.getElementById("tg_code_input").value =
                    this.dataset.tgcode;
                  document.getElementById("marke_input").value = "";
                  document.getElementById("typ_input").value = "";
                  document.querySelector(".search-form form").submit();
                });
                historyList.appendChild(li);
              });
            } else {
              const li = document.createElement("li");
              li.textContent = "No history yet.";
              li.style.cursor = "default";
              historyList.appendChild(li);
            }
          }

          // Cookie helper functions (setCookie, getCookie) are now globally defined in the script block above

          // Accordion Logic
          const accHeaders = document.querySelectorAll(".accordion-header");
          accHeaders.forEach((header) => {
            header.addEventListener("click", function () {
              this.classList.toggle("active");
              const panel = this.nextElementSibling;
              if (panel.style.display === "block") {
                panel.style.display = "none";
              } else {
                panel.style.display = "block";
              }
              // Save open accordion state to cookie
              const openAccordions = [];
              accHeaders.forEach((h) => {
                if (h.classList.contains("active")) {
                  openAccordions.push(h.textContent.trim());
                }
              });
              setCookie("openAccordions", JSON.stringify(openAccordions), 180); // Uses global setCookie (was 180 days)
            });
          });

          // Restore accordion state from cookie or open the first one
          if (accHeaders.length > 0) {
            const carDetailsTitle = document.querySelector("h2");
            // Check if the h2 "Car Details" exists, indicating single result view
            if (
              carDetailsTitle &&
              carDetailsTitle.textContent.trim() === "Car Details"
            ) {
              const savedOpenAccordions = getCookie("openAccordions");
              if (savedOpenAccordions) {
                try {
                  const openLabels = JSON.parse(savedOpenAccordions);
                  accHeaders.forEach((header) => {
                    if (openLabels.includes(header.textContent.trim())) {
                      header.classList.add("active");
                      header.nextElementSibling.style.display = "block";
                    }
                  });
                } catch (e) {
                  console.error("Error parsing accordion cookie", e);
                }
              } else {
                // Default: Open the first accordion panel if no cookie
                const firstHeader = accHeaders[0];
                firstHeader.classList.add("active");
                firstHeader.nextElementSibling.style.display = "block";
              }
            }
          }

          const historyBtn = document.getElementById("search_history_btn");
          const historyContainer = document.getElementById(
            "search_history_container"
          );

          if (historyBtn && historyContainer) {
            historyBtn.addEventListener("click", function (event) {
              event.stopPropagation();
              const isVisible = historyContainer.style.display === "block";
              if (isVisible) {
                historyContainer.style.display = "none";
              } else {
                displaySearchHistory();
                historyContainer.style.display = "block";
              }
            });

            document.addEventListener("click", function (event) {
              if (
                historyContainer.style.display === "block" &&
                !historyContainer.contains(event.target) &&
                !historyBtn.contains(event.target)
              ) {
                historyContainer.style.display = "none";
              }
            });
          }

          // Handle clicks on TG-Codes in multiple results
          const multipleResultsList = document.querySelector(
            ".multiple-results-list"
          );
          if (multipleResultsList) {
            multipleResultsList.addEventListener("click", function (event) {
              let targetElement = event.target;
              // Traverse up if the click was on the <strong> or text node inside the div
              while (
                targetElement != null &&
                !targetElement.classList.contains("clickable-tg-code")
              ) {
                targetElement = targetElement.parentElement;
              }

              if (
                targetElement &&
                targetElement.classList.contains("clickable-tg-code")
              ) {
                const tgCode = targetElement.dataset.tgcode;
                if (tgCode) {
                  document.getElementById("tg_code_input").value = tgCode;
                  document.getElementById("marke_input").value = ""; // Clear Marke field
                  document.getElementById("typ_input").value = ""; // Clear Typ field
                  document.querySelector(".search-form form").submit();
                }
              }
            });
          }
        });
      </script>
    </div>
  </body>
</html>
